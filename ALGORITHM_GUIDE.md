# 0到1掌握 A* (A-Star) 寻路算法 - PCB 爬电距离计算版

这个文档旨在帮助非算法背景的开发者理解本项目核心的寻路逻辑。

## 1. 核心任务：什么是爬电距离？
在 PCB 设计中，**爬电距离 (Creepage Distance)** 指的是两个导体之间沿绝缘表面的最短路径。
如果这个距离太短，高压电弧可能会沿着板子表面爬过去导致短路。
我们的任务就是：**在有障碍物（挖槽、其他铜皮）的二维网格地图上，找到起点到终点的最短连线。**

## 2. 为什么不用简单的直线？
因为中间可能有“挖槽（Slot）”或者“其他铜皮（Conductor）”挡路。电流不能穿过空气（挖槽），也不能碰到其他网络（铜皮）。我们需要绕路。

## 3. 算法选择：A* (A-Star)
A* 是游戏开发和地图导航中最常用的算法。它结合了两个算法的优点：
1.  **Dijkstra 算法**：保证找到最短路径，但它是向四面八方盲目搜索，效率低。
2.  **贪婪最佳优先搜索 (Greedy Best-First Search)**：只朝目标方向冲，速度快，但遇到障碍物绕路时可能不是最短路径。

A* 的核心公式：
$$F = G + H$$

- **G (Ground Cost)**: 从起点走到当前格子的**实际代价**（走过的步数）。
- **H (Heuristic)**: 从当前格子飞到终点的**预估代价**（忽略障碍物的直线距离）。
- **F (Final Score)**: 综合评分。F 越小，说明这条路既短（G小），又离终点近（H小），应该优先尝试。

## 4. 算法步骤详解 (配合代码阅读)

想象你在一个方格地图上：

1.  **初始化 (Open Set & Closed Set)**
    - 拿两个桶，一个叫“待检查 (Open Set)”，一个叫“已检查 (Closed Set)”。
    - 把**起点**扔进“待检查”桶里。

2.  **循环寻找**
    - 只要“待检查”桶里还有格子：
        - **步骤 A**: 找出 F 值最小的格子。也就是目前看来最靠谱的一步。
        - **步骤 B**: 如果这个格子就是**终点**，恭喜！倒推回去就是路径。
        - **步骤 C**: 如果不是，把它移到“已检查”桶（以后不再处理它）。
        - **步骤 D**: 看看它周围的 8 个邻居（上下左右+对角线）。

3.  **检查邻居**
    - 对于每一个邻居：
        - 如果它是墙（Slot/Conductor）或者已经在“已检查”桶里 -> **跳过**。
        - **计算 G 值**:
            - 如果是上下左右移动，代价 +1.0。
            - 如果是对角线移动，代价 +1.414 ($\sqrt{2}$)。
            - 新的 G = 当前格子的 G + 移动代价。
        - **更新数据**:
            - 如果这个邻居不在“待检查”桶里，或者新的 G 比它原来的 G 更小（说明找到了一条更近的路）：
                - 更新它的爸爸（Parent）指向当前格子（为了最后回溯路径）。
                - 更新它的 G 和 F。
                - 把它加入“待检查”桶。

4.  **回溯路径**
    - 从终点开始，顺着“爸爸”指针一直往回找，直到起点。这就是最短路径。

## 5. 本项目中的特殊细节

### 对角线移动 (Diagonal Movement)
代码中定义了：
```typescript
export const COST_STRAIGHT = 1.0;
export const COST_DIAGONAL = 1.4142; // 根号2
```
这是因为在物理世界中，斜着走确实比横着走远一点点。

### 拐角限制 (Corner Cutting)
这是一个容易忽略的细节。
```
[墙] [终]
[起] [墙]
```
如果是这种情况，虽然数学上 (0,0) 到 (1,1) 是通的，但实际上你在穿过两个墙角的缝隙。在 PCB 物理规则或者游戏物理碰撞中，通常不允许这样“挤”过去。
代码中的 `Corner Cutting logic` 部分就是防止这种情况：如果左右两边都有阻挡，就不允许走对角线。

---
建议您现在打开 `services/pathfindingService.ts`，配合本文档阅读代码中的注释。